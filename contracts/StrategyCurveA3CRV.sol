// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import {BaseStrategy} from "@yearnvaults/contracts/BaseStrategy.sol";
import {SafeERC20, SafeMath, IERC20, Address} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Math} from "@openzeppelin/contracts/math/Math.sol";

import "./interfaces/curve.sol";
import {IUniswapV2Router02} from "./interfaces/uniswap.sol";


contract StrategyCurveA3crv is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    address private uniswapRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address private sushiswapRouter = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;

    address public crvRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;
    address public a3crvPool = 0xDeBF20617708857ebe4F679508E7b7863a8A8EeE;
    address[] public crvPath;
    address[] public crvPathDai;
    address[] public crvPathUsdc;
    address[] public crvPathUsdt;

    Gauge public CurveLiquidityGaugeV2 = Gauge(address(0xd662908ADA2Ea1916B3318327A97eB18aD588b5d));
    ICurveFi public StableSwapA3CRV = ICurveFi(a3crvPool);

    IERC20 public DAI = IERC20(address(0x6B175474E89094C44Da98b954EedeAC495271d0F));
    IERC20 public USDC = IERC20(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48));
    IERC20 public USDT = IERC20(address(0xdAC17F958D2ee523a2206206994597C13D831ec7));
    ICrvV3 public CRV = ICrvV3(address(0xD533a949740bb3306d119CC777fa900bA034cd52));

    bool optimizePath = true;

    constructor(address _vault) public BaseStrategy(_vault) {
        // You can set these parameters on deployment to whatever you want
        // maxReportDelay = 6300;
        // profitFactor = 100;
        // debtThreshold = 0;
        want.safeApprove(address(CurveLiquidityGaugeV2), uint256(- 1));
        CRV.approve(crvRouter, uint256(- 1));

        // using all unwrapped tokens since there is a risk of insufficient funds for wrapped if swapping directly (sushiswap)
        crvPathDai = new address[](2);
        crvPathDai[0] = address(CRV);
        crvPathDai[1] = address(DAI);

        crvPathUsdc = new address[](2);
        crvPathUsdc[0] = address(CRV);
        crvPathUsdc[1] = address(USDC);

        crvPathUsdt = new address[](2);
        crvPathUsdt[0] = address(CRV);
        crvPathUsdt[1] = address(USDT);

        crvPath = crvPathDai;
    }

    function name() external override view returns (string memory) {
        // Add your own name here, suggestion e.g. "StrategyCreamYFI"
        return "StrategyCurveA3crv";
    }

    function estimatedTotalAssets() public override view returns (uint256) {
        return CurveLiquidityGaugeV2.balanceOf(address(this));
    }

    function prepareReturn(uint256 _debtOutstanding) internal override
    returns (
        uint256 _profit,
        uint256 _loss,
        uint256 _debtPayment
    )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position

        uint256 guageTokens = CurveLiquidityGaugeV2.balanceOf(address(this));
        if (guageTokens > 0) {
            CurveLiquidityGaugeV2.claim_rewards();
            IMinter(CRV.minter()).mint(address(CurveLiquidityGaugeV2));

            uint256 crvBalance = CRV.balanceOf(address(this));
            if (crvBalance > 0) {
                _sell(crvBalance);
            }
            uint256 daiBalance = DAI.balanceOf(address(this));
            if (daiBalance > 0) {
                DAI.approve(a3crvPool, daiBalance);
                StableSwapA3CRV.add_liquidity([daiBalance, 0, 0], 0, true);
            }
            uint256 usdcBalance = USDC.balanceOf(address(this));
            if (usdcBalance > 0) {
                USDC.approve(a3crvPool, usdcBalance);
                StableSwapA3CRV.add_liquidity([0, usdcBalance, 0], 0, true);
            }
            uint256 usdtBalance = USDT.balanceOf(address(this));
            if (usdtBalance > 0) {
                USDT.approve(a3crvPool, usdtBalance);
                StableSwapA3CRV.add_liquidity([0, 0, usdtBalance], 0, true);
            }

            _profit = want.balanceOf(address(this));
        }

        if (_debtOutstanding > 0) {
            if (_debtOutstanding > _profit) {
                uint256 stakedBal = CurveLiquidityGaugeV2.balanceOf(address(this));
                CurveLiquidityGaugeV2.withdraw(Math.min(stakedBal, _debtOutstanding - _profit));
            }

            _debtPayment = Math.min(_debtOutstanding, want.balanceOf(address(this)).sub(_profit));
        }
    }


    function adjustPosition(uint256 _debtOutstanding) internal override {
        uint256 _toInvest = want.balanceOf(address(this));
        CurveLiquidityGaugeV2.deposit(_toInvest);
    }

    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount, uint256 _loss){
        uint256 wantBal = want.balanceOf(address(this));
        uint256 stakedBal = CurveLiquidityGaugeV2.balanceOf(address(this));

        if (_amountNeeded > wantBal) {
            CurveLiquidityGaugeV2.withdraw(Math.min(stakedBal, _amountNeeded - wantBal));
        }

        _liquidatedAmount = Math.min(_amountNeeded, want.balanceOf(address(this)));
    }

    function setOptimizePath(bool _toOptimize) external onlyAuthorized {
        optimizePath = _toOptimize;
    }

    function _sell(uint256 amount) internal {
        if (optimizePath) {
            crvPath = _pathToSmallestReserve();
        }
        IUniswapV2Router02(crvRouter).swapExactTokensForTokens(amount, uint256(0), crvPath, address(this), now);
    }

    // Find lowest reserve in pool. Amount to deposit likely won't make enough of a difference to need to split into more than 1 reserve
    function _pathToSmallestReserve() internal view returns (address[] memory){
        uint256 balanceDai = StableSwapA3CRV.balances(0) / (10 ** 18);
        uint256 balanceUsdc = StableSwapA3CRV.balances(1) / (10 ** 6);
        uint256 balanceUsdt = StableSwapA3CRV.balances(2) / (10 ** 6);

        // dai min
        if (balanceDai < balanceUsdc && balanceDai < balanceUsdt) {
            return crvPathDai;
            // usdc min
        } else if (balanceUsdc < balanceUsdt && balanceUsdc < balanceDai) {
            return crvPathUsdc;
            // usdt min
        } else {
            return crvPathUsdt;
        }
    }

    function setCRVRouter(bool isUniswap, address[] calldata _path) public onlyGovernance {
        if (isUniswap) {
            crvRouter = uniswapRouter;
        } else {
            crvRouter = sushiswapRouter;
        }
        crvPath = _path;
        CRV.approve(crvRouter, uint256(- 1));
    }

    function prepareMigration(address _newStrategy) internal override {
        // TODO: Transfer any non-`want` tokens to the new strategy
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
        prepareReturn(CurveLiquidityGaugeV2.balanceOf(address(this)));
    }

    // crv rewards are always sold for underlying dai, usdc, usdt and immediately deposited back in to the pool
    function protectedTokens() internal override view returns (address[] memory) {
        address[] memory protected = new address[](1);
        protected[0] = address(CurveLiquidityGaugeV2);
        return protected;
    }

    receive() external payable {}
}   
